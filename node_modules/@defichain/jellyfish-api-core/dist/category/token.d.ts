import BigNumber from 'bignumber.js';
import { ApiClient } from '../.';
/**
 * Token RPCs for DeFi Blockchain
 */
export declare class Token {
    private readonly client;
    constructor(client: ApiClient);
    /**
     * Creates a token with given metadata
     *
     * @param {CreateTokenMetadata} metadata
     * @param {string} metadata.symbol token's symbol (unique)
     * @param {string} metadata.name token's name (unique)
     * @param {boolean} metadata.isDAT default = false
     * @param {boolean} metadata.mintable default = true
     * @param {boolean} metadata.tradeable default = true
     * @param {string} metadata.collateralAddress for keeping collateral amount
     * @param {UTXO[]} utxos array of specific UTXOs to spend
     * @param {string} utxos.txid
     * @param {number} utxos.vout
     * @return {Promise<string>}
     */
    createToken(metadata: CreateTokenMetadata, utxos?: UTXO[]): Promise<string>;
    /**
     * Updates a token with given metadata
     *
     * @param {string} token symbolKey, id ror creation tx
     * @param {UpdateTokenMetadata} [metadata]
     * @param {string} [metadata.symbol]
     * @param {string} [metadata.name]
     * @param {boolean} [metadata.isDAT]
     * @param {boolean} [metadata.mintable]
     * @param {boolean} [metadata.tradeable]
     * @param {boolean} [metadata.finalize]
     * @return {Promise<string>}
     */
    updateToken(token: string, metadata?: UpdateTokenMetadata): Promise<string>;
    /**
     * Returns information about tokens
     *
     * @param {TokenPagination} pagination
     * @param {number} pagination.start
     * @param {boolean} pagination.including_start
     * @param {number} pagination.limit
     * @param {boolean} verbose
     * @return {Promise<TokenResult>}
     */
    listTokens(pagination?: TokenPagination, verbose?: boolean): Promise<TokenResult>;
    /**
     * Return information about token
     *
     * @param {string} symbolKey
     * @return {Promise<TokenResult>}
     */
    getToken(symbolKey: string): Promise<TokenResult>;
    /**
     * Creates a transaction to mint tokens.
     *
     * @param {string[]} options.amounts formatted as `${number}@${string}`
     * @param {UTXO[]} [options.utxos = []]
     * @param {string} [options.utxos.txid]
     * @param {number} [options.utxos.vout]
     * @param {string} [options.to] address to send minted tokens to
     * @return {Promise<string>}
     */
    mintTokens(options: MintTokensOptions): Promise<string>;
    /**
     * Creates a transaction to burn tokens.
     *
     * @param {string} amounts Amount as json string, or array. Example: '[ \"amount@token\" ]'
     * @param {string} [from] Address containing tokens to be burned
     * @param {string} [context] Additional data necessary for specific burn type
     * @param {UTXO[]} [utxos = []] A json array of json objects. Provide it if you want to spent specific UTXOs
     * @param {string} [utxos.txid] The transaction id
     * @param {number} [utxos.vout] The output number
     * @return {Promise<string>} The hex-encoded hash of broadcasted transaction
     */
    burnTokens(amounts: string, from?: string, context?: string, utxos?: UTXO[]): Promise<string>;
    /**
     * Get detailed information about any custom transaction.
     *
     * @param {string} txid Transaction hash
     * @param {string} [blockhash] (for confirmed transactions) Hash of the block of the  transaction
     * @return {Promise<GetCustomTxResult | string>} Inferred custom transaction data, or error message
     */
    getCustomTx(txid: string, blockhash?: string): Promise<GetCustomTxResult | string>;
    /**
     * Get detailed information about any custom transaction from the raw transaction.
     *
     * @param {string} hexstring Serialised custom transaction data
     * @param {boolean} [iswitness] is the transaction a serialised witness transaction
     * @return {Promise<DecodeCustomTxResult | string>} Inferred custom transaction data, or error message
     */
    decodeCustomTx(hexstring: string, iswitness?: boolean): Promise<DecodeCustomTxResult | string>;
}
export interface TokenResult {
    [id: string]: TokenInfo;
}
export interface TokenInfo {
    symbol: string;
    symbolKey: string;
    name: string;
    decimal: BigNumber;
    limit: BigNumber;
    mintable: boolean;
    tradeable: boolean;
    isDAT: boolean;
    isLPS: boolean;
    isLoanToken: boolean;
    finalized: boolean;
    minted: BigNumber;
    creationTx: string;
    creationHeight: BigNumber;
    destructionTx: string;
    destructionHeight: BigNumber;
    collateralAddress: string;
}
export interface CreateTokenMetadata {
    symbol: string;
    name: string;
    isDAT: boolean;
    mintable: boolean;
    tradeable: boolean;
    collateralAddress: string;
}
export interface UpdateTokenMetadata {
    symbol?: string;
    name?: string;
    isDAT?: boolean;
    mintable?: boolean;
    tradeable?: boolean;
    finalize?: boolean;
}
export interface TokenPagination {
    start: number;
    including_start: boolean;
    limit: number;
}
export interface UTXO {
    txid: string;
    vout: number;
}
export interface GetCustomTxResult {
    type: string;
    valid: boolean;
    results: object;
    blockHeight: string;
    blockhash: string;
    confirmations: number;
}
export interface DecodeCustomTxResult {
    txid: string;
    type: string;
    valid: boolean;
    results: object;
}
export interface MintTokensOptions {
    amounts: string[];
    utxos?: UTXO[];
    to?: string;
}
//# sourceMappingURL=token.d.ts.map