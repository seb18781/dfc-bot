"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Token = void 0;
/**
 * Token RPCs for DeFi Blockchain
 */
class Token {
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a token with given metadata
     *
     * @param {CreateTokenMetadata} metadata
     * @param {string} metadata.symbol token's symbol (unique)
     * @param {string} metadata.name token's name (unique)
     * @param {boolean} metadata.isDAT default = false
     * @param {boolean} metadata.mintable default = true
     * @param {boolean} metadata.tradeable default = true
     * @param {string} metadata.collateralAddress for keeping collateral amount
     * @param {UTXO[]} utxos array of specific UTXOs to spend
     * @param {string} utxos.txid
     * @param {number} utxos.vout
     * @return {Promise<string>}
     */
    createToken(metadata, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const defaultMetadata = {
                isDAT: false,
                mintable: true,
                tradeable: true
            };
            return yield this.client.call('createtoken', [Object.assign(Object.assign({}, defaultMetadata), metadata), utxos], 'number');
        });
    }
    /**
     * Updates a token with given metadata
     *
     * @param {string} token symbolKey, id ror creation tx
     * @param {UpdateTokenMetadata} [metadata]
     * @param {string} [metadata.symbol]
     * @param {string} [metadata.name]
     * @param {boolean} [metadata.isDAT]
     * @param {boolean} [metadata.mintable]
     * @param {boolean} [metadata.tradeable]
     * @param {boolean} [metadata.finalize]
     * @return {Promise<string>}
     */
    updateToken(token, metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('updatetoken', [token, metadata], 'number');
        });
    }
    /**
     * Returns information about tokens
     *
     * @param {TokenPagination} pagination
     * @param {number} pagination.start
     * @param {boolean} pagination.including_start
     * @param {number} pagination.limit
     * @param {boolean} verbose
     * @return {Promise<TokenResult>}
     */
    listTokens(pagination = {
        start: 0,
        including_start: true,
        limit: 100
    }, verbose = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('listtokens', [pagination, verbose], 'bignumber');
        });
    }
    /**
     * Return information about token
     *
     * @param {string} symbolKey
     * @return {Promise<TokenResult>}
     */
    getToken(symbolKey) {
        return __awaiter(this, void 0, void 0, function* () {
            // Note(canonbrother): only 'limit' and 'minted' is bignumber
            // but the 'return' contains random id which is not be able to map precision exactly
            // precision: { '0': limit: 'bignumber', minted: 'bignumber'}
            return yield this.client.call('gettoken', [symbolKey], 'bignumber');
        });
    }
    /**
     * Creates a transaction to mint tokens.
     *
     * @param {string[]} options.amounts formatted as `${number}@${string}`
     * @param {UTXO[]} [options.utxos = []]
     * @param {string} [options.utxos.txid]
     * @param {number} [options.utxos.vout]
     * @param {string} [options.to] address to send minted tokens to
     * @return {Promise<string>}
     */
    mintTokens(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('minttokens', [options], 'number');
        });
    }
    /**
     * Creates a transaction to burn tokens.
     *
     * @param {string} amounts Amount as json string, or array. Example: '[ \"amount@token\" ]'
     * @param {string} [from] Address containing tokens to be burned
     * @param {string} [context] Additional data necessary for specific burn type
     * @param {UTXO[]} [utxos = []] A json array of json objects. Provide it if you want to spent specific UTXOs
     * @param {string} [utxos.txid] The transaction id
     * @param {number} [utxos.vout] The output number
     * @return {Promise<string>} The hex-encoded hash of broadcasted transaction
     */
    burnTokens(amounts, from, context, utxos = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('burntokens', [{ amounts, from, context }, utxos], 'number');
        });
    }
    /**
     * Get detailed information about any custom transaction.
     *
     * @param {string} txid Transaction hash
     * @param {string} [blockhash] (for confirmed transactions) Hash of the block of the  transaction
     * @return {Promise<GetCustomTxResult | string>} Inferred custom transaction data, or error message
     */
    getCustomTx(txid, blockhash) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.call('getcustomtx', [txid, blockhash], 'number');
        });
    }
    /**
     * Get detailed information about any custom transaction from the raw transaction.
     *
     * @param {string} hexstring Serialised custom transaction data
     * @param {boolean} [iswitness] is the transaction a serialised witness transaction
     * @return {Promise<DecodeCustomTxResult | string>} Inferred custom transaction data, or error message
     */
    decodeCustomTx(hexstring, iswitness) {
        return __awaiter(this, void 0, void 0, function* () {
            if (iswitness === undefined) {
                return yield this.client.call('decodecustomtx', [hexstring], 'number');
            }
            return yield this.client.call('decodecustomtx', [hexstring, iswitness], 'number');
        });
    }
}
exports.Token = Token;
//# sourceMappingURL=token.js.map