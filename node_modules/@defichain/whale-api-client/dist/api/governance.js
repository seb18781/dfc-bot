"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProposalVoteResultType = exports.GovernanceProposalStatus = exports.GovernanceProposalType = exports.Governance = void 0;
const governance_1 = require("@defichain/jellyfish-api-core/dist/category/governance");
class Governance {
    constructor(client) {
        this.client = client;
    }
    /**
     * Paginate query on-chain governance proposals
     *
     * @param {ListProposalsStatus} [status=ListProposalsStatus.ALL] proposal status
     * @param {ListProposalsType} [type=ListProposalsType.ALL] proposal type
     * @param {number} [cycle=0] cycle: 0 (show all), cycle: N (show cycle N), cycle: -1 (show previous cycle)
     * @param {number} [size=30] of proposal to query
     * @param {string} next set of proposals
     * @param {boolean} all true to return all records, otherwise it will return based on size param
     * @returns {Promise<ApiPagedResponse<ProposalInfo>>}
     */
    listGovProposals(option) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', 'governance/proposals', (_a = option === null || option === void 0 ? void 0 : option.size) !== null && _a !== void 0 ? _a : 30, option === null || option === void 0 ? void 0 : option.next, {
                status: (_b = option === null || option === void 0 ? void 0 : option.status) !== null && _b !== void 0 ? _b : governance_1.ListProposalsStatus.ALL,
                type: (_c = option === null || option === void 0 ? void 0 : option.type) !== null && _c !== void 0 ? _c : governance_1.ListProposalsType.ALL,
                cycle: (_d = option === null || option === void 0 ? void 0 : option.cycle) !== null && _d !== void 0 ? _d : 0,
                all: (_e = option === null || option === void 0 ? void 0 : option.all) !== null && _e !== void 0 ? _e : false
            });
        });
    }
    /**
     * Get information about a vault with given vault id.
     *
     * @param {string} id proposal ID
     * @returns {Promise<GovernanceProposal>}
     */
    getGovProposal(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestData('GET', `governance/proposals/${id}`);
        });
    }
    /**
     * Returns votes for a proposal
     *
     * @param {GovernanceListGovProposalVotesOptions} [option]
     * @param {string} [option.id] proposal ID
     * @param {MasternodeType | string} [option.masternode=MasternodeType.ALL] masternode id or reserved words 'mine' to list votes for all owned accounts or 'all' to list all votes
     * @param {number} [option.cycle=0] cycle: 0 (show current), cycle: N (show cycle N), cycle: -1 (show all)
     * @param {number} [option.size=30] of proposal to query
     * @param {string} [option.next] set of proposals
     * @param {boolean} [option.all] true to return all records, otherwise it will return based on size param
     * @return {Promise<ProposalVotesResult[]>} Proposal vote information
     */
    listGovProposalVotes(option) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.client.requestList('GET', `governance/proposals/${(_a = option === null || option === void 0 ? void 0 : option.id) !== null && _a !== void 0 ? _a : ''}/votes`, (_b = option === null || option === void 0 ? void 0 : option.size) !== null && _b !== void 0 ? _b : 30, option === null || option === void 0 ? void 0 : option.next, {
                masternode: (_c = option === null || option === void 0 ? void 0 : option.masternode) !== null && _c !== void 0 ? _c : governance_1.MasternodeType.MINE,
                cycle: (_d = option === null || option === void 0 ? void 0 : option.cycle) !== null && _d !== void 0 ? _d : 0,
                all: (_e = option === null || option === void 0 ? void 0 : option.all) !== null && _e !== void 0 ? _e : false
            });
        });
    }
}
exports.Governance = Governance;
var GovernanceProposalType;
(function (GovernanceProposalType) {
    GovernanceProposalType["COMMUNITY_FUND_PROPOSAL"] = "CommunityFundProposal";
    GovernanceProposalType["VOTE_OF_CONFIDENCE"] = "VoteOfConfidence";
})(GovernanceProposalType = exports.GovernanceProposalType || (exports.GovernanceProposalType = {}));
var GovernanceProposalStatus;
(function (GovernanceProposalStatus) {
    GovernanceProposalStatus["VOTING"] = "Voting";
    GovernanceProposalStatus["REJECTED"] = "Rejected";
    GovernanceProposalStatus["COMPLETED"] = "Completed";
})(GovernanceProposalStatus = exports.GovernanceProposalStatus || (exports.GovernanceProposalStatus = {}));
var ProposalVoteResultType;
(function (ProposalVoteResultType) {
    ProposalVoteResultType["YES"] = "YES";
    ProposalVoteResultType["NO"] = "NO";
    ProposalVoteResultType["NEUTRAL"] = "NEUTRAL";
    ProposalVoteResultType["UNKNOWN"] = "UNKNOWN";
})(ProposalVoteResultType = exports.ProposalVoteResultType || (exports.ProposalVoteResultType = {}));
//# sourceMappingURL=governance.js.map